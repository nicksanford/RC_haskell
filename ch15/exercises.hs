module Exerciese where

import Data.Semigroup as S

import Data.Monoid as M
--import Control.Monad
import Test.QuickCheck

data Optional a = Nada
                | Only a
                deriving (Eq, Show)

instance Monoid a => Monoid (Optional a) where
  mempty = Nada
  mappend a Nada = a
  mappend Nada b = b
  mappend (Only a) (Only b) = Only (M.mappend a b)

type Verb = String
type Adjective = String
type Adverb = String
type Noun = String
type Exclamation = String

madlibbin' :: Exclamation -> Adverb -> Noun -> Adjective -> String
madlibbin' e adv noun adj =
  e M.<> "! he said " M.<>
  adv M.<> " as he jumped into his car " M.<>
  noun M.<> " and drove off with his " M.<>
  adj M.<> " wife."

madlibbin :: Exclamation -> Adverb -> Noun -> Adjective -> String
madlibbin e adv noun adj =
  M.mappend e
   (M.mappend "! he said "
    (M.mappend adv (M.mappend " as he jumped into his car "
      (M.mappend noun
       (M.mappend " and drove off with his "
        (M.mappend adj  " wife.")
       )
      )
     )
    )
   )

data Bull = Fools
          | Twoo
          deriving (Eq, Show)

instance Arbitrary Bull where
  arbitrary = frequency [ (1, return Fools)
                        , (1, return Twoo)]
instance Monoid Bull where
  mempty = Fools
  mappend _ _ = Fools

type BoolMapped = Bull -> Bull -> Bull -> Bool


newtype First' a = First' { getFirst :: Optional a}
                 deriving (Eq, Show)

instance Monoid (First' a) where
  mempty = First' Nada 
  mappend (First' Nada) x = x
  mappend x (First' Nada) = x
  mappend x@(First' (Only _)) _ = x

instance (Arbitrary a) => Arbitrary (First' a) where
  arbitrary = do
    a <- arbitrary
    frequency [ (1, return $ First' Nada)
              , (10, return $ First' (Only a) )]

firstMappend :: First' a -> First' a -> First' a
firstMappend = M.mappend

semiGroupAssoc :: (Semigroup a, Eq a) => a -> a -> a -> Bool
semiGroupAssoc a b c = ((a S.<> b ) S.<> c) == (a S.<> (b S.<> c))

monoidAsssoc :: (Monoid a, Eq a) => a -> a -> a -> Bool
monoidAsssoc a b c = (a M.<> b) M.<> c == a M.<> (b M.<> c)

monoidLeftIdentity :: (Monoid a, Eq a) => a -> Bool
monoidLeftIdentity a = (M.mempty M.<> a) == a

monoidRightIdentity :: (Monoid a, Eq a) => a -> Bool
monoidRightIdentity a = (a M.<> M.mempty) == a

-- TODO I know it shouldn't be necessary to define all these functions for just dealing with Blind newtypes, but I don't know how else to get this working for functions generated by quickcheck (which don't have show instnaes).
combineSemiGroupAssoc :: (Semigroup b, Eq b) => Blind (Combine a b) ->
                                                Blind (Combine a b) ->
                                                Blind (Combine a b) ->
                                                a                   ->
                                                Bool

combineSemiGroupAssoc (Blind f) (Blind g) (Blind h) a =
  (unCombine $ (f S.<> g) S.<> h) a == (unCombine $ f S.<> (g S.<> h)) a

-- TODO I know it shouldn't be necessary to define all these functions for just dealing with Comp & Combine newtypes, but I don't know how to unwrap the generated functions otherwise.

compSemiGroupAssoc :: (Eq a) => Blind (Comp a) ->
                                Blind (Comp a) ->
                                Blind (Comp a) ->
                                a ->
                                Bool
compSemiGroupAssoc (Blind f) (Blind g) (Blind h) a = (unComp $ (f S.<> g) S.<> h) a == (unComp $ f S.<> (g S.<> h)) a

combineMonoidAssoc :: (Monoid b, Eq b) => Blind (Combine a b) ->
                                          Blind (Combine a b) ->
                                          Blind (Combine a b) ->
                                          a ->
                                          Bool
combineMonoidAssoc (Blind f) (Blind g) (Blind h) a =
  (unCombine $ (f M.<> g) M.<> h) a == (unCombine $ f M.<> (g M.<> h)) a


combineMonoidLeftIdentity :: (Monoid b, Eq b) => Blind (Combine a b) -> a -> Bool
combineMonoidLeftIdentity (Blind a) i = ((unCombine $ (M.mempty M.<> a)) i) == (unCombine $ a) i

combineMonoidRightIdentity :: (Monoid b, Eq b) => Blind (Combine a b) -> a -> Bool
combineMonoidRightIdentity (Blind a) i = ((unCombine $ (a M.<> M.mempty)) i) == (unCombine $ a) i


compMonoidAssoc :: (Monoid a, Eq a) => Blind (Comp a) ->
                                          Blind (Comp a) ->
                                          Blind (Comp a) ->
                                          a ->
                                          Bool
compMonoidAssoc (Blind f) (Blind g) (Blind h) a =
  (unComp $ (f M.<> g) M.<> h) a == (unComp $ f M.<> (g M.<> h)) a

compMonoidLeftIdentity :: (Monoid a, Eq a) => Blind (Comp a) -> a -> Bool
compMonoidLeftIdentity (Blind a) i = (unComp $ M.mempty M.<> a) i == (unComp a) i

compMonoidRightIdentity :: (Monoid a, Eq a) => Blind (Comp a) -> a -> Bool
compMonoidRightIdentity (Blind a) i = (unComp $ a M.<> M.mempty) i == (unComp a) i

memMonoidAssoc :: (Monoid a, Eq a, Eq s) => Blind (Mem s a) ->
                                      Blind (Mem s a) ->
                                      Blind (Mem s a) ->
                                      s ->
                                      Bool
memMonoidAssoc (Blind f) (Blind g) (Blind h) a =
  (runMem $ (f M.<> g) M.<> h) a == (runMem $ f M.<> (g M.<> h)) a

memMonoidLeftIdentity :: (Monoid a, Eq a, Eq s) => Blind (Mem s a) -> s -> Bool
memMonoidLeftIdentity (Blind a) i =
  (runMem $ M.mempty M.<> a) i == (runMem a) i

memMonoidRightIdentity :: (Monoid a, Eq a, Eq s) => Blind (Mem s a) -> s -> Bool
memMonoidRightIdentity (Blind a) i =
  (runMem $ a M.<> M.mempty) i == (runMem a) i

-- Types
type FirstMappend = First' String ->
                    First' String ->
                    First' String -> Bool

type FstId = First' String -> Bool

data Trivial = Trivial deriving (Eq, Show)

newtype Identity a = Identity a deriving (Eq, Show)

data Two a b = Two a b deriving (Eq, Show)

data Three a b c = Three a b c deriving (Eq, Show)

data Four a b c d = Four a b c d deriving (Eq, Show)

newtype BoolConj = BoolConj Bool deriving  (Eq, Show)

newtype BoolDisj = BoolDisj Bool deriving  (Eq, Show)

data Or a b = Fst a
            | Snd b
            deriving (Eq, Show)

newtype Combine a b = Combine { unCombine :: a -> b}

newtype Comp a = Comp { unComp :: a -> a }

data Validation a b = ExFailure a
                    | ExSuccess b
                    deriving (Eq, Show)

newtype Mem s a = Mem { runMem :: s -> (a, s) }

-- Instances
instance Semigroup Trivial where
  (<>) a _ = a

instance Monoid Trivial where
  mempty = Trivial
  mappend a _ = a

instance (Semigroup a) => Semigroup (Identity a) where
  (<>) (Identity a) (Identity b) = Identity $ a S.<> b

instance (Monoid a) => Monoid (Identity a) where
  mempty = Identity mempty
  mappend (Identity a) (Identity b) = Identity $ a M.<> b

instance (Semigroup a, Semigroup b) => Semigroup (Two a b) where
  (<>)  (Two a b) (Two a' b') = Two (a S.<> a') (b S.<> b')

instance (Monoid a, Monoid b) => Monoid (Two a b) where
  mempty = Two mempty mempty
  mappend (Two a b) (Two a' b') = Two (a M.<> a') (b M.<> b')

instance (Semigroup a, Semigroup b, Semigroup c) => Semigroup (Three a b c) where
  (<>)  (Three a b c) (Three a' b' c') = Three (a S.<> a') (b S.<> b') (c S.<> c')

instance (Monoid a, Monoid b, Monoid c) => Monoid (Three a b c) where
  mempty = Three mempty mempty mempty
  mappend (Three a b c) (Three a' b' c') = Three (a M.<> a') (b M.<> b') (c M.<> c')

instance (Semigroup a, Semigroup d) => Semigroup (Four a b c d) where
  (<>)  (Four a b _ d) (Four a' _ c' d') = Four (a S.<> a') b c' (d S.<> d')

instance Semigroup BoolConj where
  (<>) (BoolConj False) (BoolConj _)     = BoolConj False
  (<>) (BoolConj _    ) (BoolConj False) = BoolConj False
  (<>) _                _                = BoolConj True

instance Monoid BoolConj where
  mempty = BoolConj True
  mappend (BoolConj False) (BoolConj _)     = BoolConj False
  mappend (BoolConj _    ) (BoolConj False) = BoolConj False
  mappend _                _                = BoolConj True

instance Semigroup BoolDisj where
  (<>) (BoolDisj False) (BoolDisj False) = BoolDisj False
  (<>) _                _              = BoolDisj True

instance Monoid BoolDisj where
  mempty = BoolDisj False
  mappend (BoolDisj False) (BoolDisj False) = BoolDisj False
  mappend _                _              = BoolDisj True

instance Semigroup (Or a b) where
  (<>) (Fst _ ) b@(Fst _) = b
  (<>) a@(Snd _)  _       = a 
  (<>) (Fst _) b@(Snd  _) = b

instance Semigroup b => Semigroup (Combine a b) where
  (<>) (Combine f) (Combine g) = Combine $ f S.<> g

instance (Monoid b) => Monoid (Combine a b) where
  mempty = Combine mempty
  mappend (Combine f) (Combine g) = Combine $ f M.<> g

instance Semigroup (Comp a) where
  (<>) (Comp f) (Comp g) = Comp $ f . g

instance (Monoid a) => Monoid (Comp a) where
  mempty = Comp mempty
  mappend (Comp f) (Comp g) = Comp $ mappend f g

instance Semigroup a => Semigroup (Validation a b) where
  (<>) a@(ExSuccess _) _ = a
  (<>) _ b@(ExSuccess _) = b
  (<>) (ExFailure a) (ExFailure b) = ExFailure $ a S.<> b

-- f' = Mem $ \s -> ("hi", s + 1)
-- main = do
-- let rmzero = runMem mempty 0 =>  ("",0)
-- print $ (rmzero :: (String, Int)) =>  ("",0)
-- rmleft = runMem (f' <> mempty) 0 => ("hi",1)
-- rmright = runMem (mempty <> f') 0
-- print $ rmleft => ("hi",1)
-- print $ rmright => ("hi",1)
-- print $ rmleft == runMem f' 0 True
-- print $ rmright == runMem f' 0 => True

instance Monoid a => Monoid (Mem s a) where
  mempty = Mem $ \x -> (mempty, x)
  mappend a b = Mem $ \x -> ((fst . (runMem a)) x M.<> (fst . (runMem b)) x,
                             ((snd . (runMem a) . snd . (runMem b)) x))

-- QuickCheck Instances
instance Arbitrary Trivial where
  arbitrary = return Trivial

instance Arbitrary a => Arbitrary (Identity a) where
  arbitrary = do
    a <- arbitrary
    return $ Identity a

instance (Arbitrary a, Arbitrary b) => Arbitrary (Two a b) where
  arbitrary =
    do
    a <- arbitrary
    b <- arbitrary
    return $ Two a b

instance (Arbitrary a, Arbitrary b, Arbitrary c) => Arbitrary (Three a b c) where
  arbitrary = do
    a <- arbitrary
    b <- arbitrary
    c <- arbitrary
    return $ Three a b c

instance (Arbitrary a, Arbitrary b, Arbitrary c, Arbitrary d) => Arbitrary (Four a b c d) where
  arbitrary = do
    a <- arbitrary
    b <- arbitrary
    c <- arbitrary
    d <- arbitrary
    return $ Four a b c d

instance Arbitrary BoolConj where
  arbitrary = do
    a <- arbitrary
    return $ BoolConj a

instance Arbitrary BoolDisj where
  arbitrary = do
    a <- arbitrary
    return $ BoolDisj a

instance (Arbitrary a, Arbitrary b) => Arbitrary (Or a b) where
  arbitrary = do
    a <- arbitrary
    b <- arbitrary
    frequency [ (1, return $ Fst a)
              , (1, return $ Snd b) ]

instance (CoArbitrary a, Arbitrary b) => Arbitrary (Combine a b) where
  arbitrary = do
    x <- arbitrary
    return $ Combine x

instance (CoArbitrary a, Arbitrary a) => Arbitrary (Comp a) where
  arbitrary = do
    x <- arbitrary
    return $ Comp x

instance (Arbitrary a, Arbitrary b) => Arbitrary (Validation a b) where
  arbitrary = do
    a <- arbitrary
    b <- arbitrary
    frequency [ (1, return $ ExFailure a)
              , (1, return $ ExSuccess b) ]

instance (CoArbitrary s, Arbitrary s, Arbitrary a) => Arbitrary (Mem s a) where
  arbitrary = do
    f <- arbitrary
    return $ Mem f
-- Type aliases for quickcheck
type TrivialAssoc = Trivial -> Trivial -> Trivial -> Bool

type IdentityAssoc = Identity String ->
                     Identity String ->
                     Identity String -> Bool

type TwoAssoc = Two String (Sum Integer) ->
                Two String (Sum Integer) ->
                Two String (Sum Integer) -> Bool

type TwoIdent = Two String [Int] -> Bool

type ThreeAssoc = Three String (Product Integer) All ->
                  Three String (Product Integer) All ->
                  Three String (Product Integer) All -> Bool

type ThreeIdent = Three String [Int] All -> Bool

type FourAssoc = Four String Integer Bool (Identity String) ->
                 Four String Integer Bool (Identity String) ->
                 Four String Integer Bool (Identity String) -> Bool

type BoolConjAssoc = BoolConj ->
                     BoolConj ->
                     BoolConj -> Bool

type BoolConjIdent = BoolConj -> Bool

type BoolDisjAssoc = BoolDisj ->
                    BoolDisj ->
                    BoolDisj -> Bool

type BoolDisjIdent = BoolDisj -> Bool

type OrAssoc = Or String [Integer] ->
               Or String [Integer] ->
               Or String [Integer] -> Bool

type CombineAssoc = Blind (Combine Integer String) ->
                    Blind (Combine Integer String) ->
                    Blind (Combine Integer String) ->
                    Integer ->
                    Bool

type CombineIdent = Blind (Combine Integer String) ->
                    Integer ->
                    Bool

type CompAssoc = Blind (Comp (Sum Integer)) ->
                 Blind (Comp (Sum Integer)) ->
                 Blind (Comp (Sum Integer)) ->
                 (Sum Integer) ->
                 Bool

type CompIdent = Blind (Comp (Sum Integer)) ->
                 Sum Integer ->
                 Bool

type ValidationAssoc = Validation String Int ->
                       Validation String Int ->
                       Validation String Int ->
                       Bool

type MemAssoc = Blind (Mem Integer String) ->
                Blind (Mem Integer String) ->
                Blind (Mem Integer String) ->
                Integer ->
                Bool

type MemIdent = Blind (Mem Integer String) ->
                Integer ->
                Bool


main :: IO ()
main = do
  -- let ma = monoidAsssoc
  --     mli = monoidLeftIdentity
  --     mri = monoidRightIdentity
  -- quickCheck (ma  :: Bull -> Bull -> Bull -> Bool)
  -- quickCheck (mli :: Bull -> Bool)
  -- quickCheck (mri :: Bull -> Bo
  quickCheck (monoidAsssoc  :: FirstMappend)
  quickCheck (monoidLeftIdentity ::FstId)
  quickCheck (monoidRightIdentity :: FstId)
  quickCheck (semiGroupAssoc :: TrivialAssoc)
  quickCheck (semiGroupAssoc :: IdentityAssoc)
  quickCheck (semiGroupAssoc :: TwoAssoc)
  quickCheck (semiGroupAssoc :: ThreeAssoc)
  quickCheck (semiGroupAssoc :: FourAssoc)
  quickCheck (semiGroupAssoc :: BoolConjAssoc)
  quickCheck (semiGroupAssoc :: BoolDisjAssoc)
  quickCheck (semiGroupAssoc :: OrAssoc)
  quickCheck (combineSemiGroupAssoc :: CombineAssoc)
  quickCheck (compSemiGroupAssoc :: CompAssoc)
  quickCheck (semiGroupAssoc :: ValidationAssoc)

  quickCheck (monoidAsssoc :: TrivialAssoc)
  quickCheck (monoidLeftIdentity :: Trivial -> Bool)
  quickCheck (monoidRightIdentity :: Trivial -> Bool)

  quickCheck (monoidAsssoc :: IdentityAssoc)
  quickCheck (monoidLeftIdentity :: Identity String -> Bool)
  quickCheck (monoidRightIdentity ::Identity String -> Bool)

  quickCheck (monoidAsssoc :: TwoAssoc)
  quickCheck (monoidLeftIdentity :: TwoIdent)
  quickCheck (monoidRightIdentity :: TwoIdent)

  quickCheck (monoidAsssoc :: ThreeAssoc)
  quickCheck (monoidLeftIdentity :: ThreeIdent)
  quickCheck (monoidRightIdentity :: ThreeIdent)

  quickCheck (monoidAsssoc :: ThreeAssoc)
  quickCheck (monoidLeftIdentity :: ThreeIdent)
  quickCheck (monoidRightIdentity :: ThreeIdent)
  
  quickCheck (monoidAsssoc :: BoolConjAssoc)
  quickCheck (monoidLeftIdentity :: BoolConjIdent)
  quickCheck (monoidRightIdentity :: BoolConjIdent)

  quickCheck (monoidAsssoc :: BoolDisjAssoc)
  quickCheck (monoidLeftIdentity :: BoolDisjIdent)
  quickCheck (monoidRightIdentity :: BoolDisjIdent)

  quickCheck (combineMonoidAssoc :: CombineAssoc)
  quickCheck (combineMonoidLeftIdentity :: CombineIdent)
  quickCheck (combineMonoidRightIdentity :: CombineIdent)

  quickCheck (compMonoidAssoc :: CompAssoc)
  quickCheck (compMonoidLeftIdentity :: CompIdent)
  quickCheck (compMonoidRightIdentity :: CompIdent)

  quickCheck (memMonoidAssoc :: MemAssoc)
  quickCheck (memMonoidLeftIdentity :: MemIdent)
  quickCheck (memMonoidRightIdentity :: MemIdent)

  print "DONE!!!"
